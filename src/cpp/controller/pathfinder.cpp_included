#include "controller/pathfinder.h"

#include "definitions.h"
#include "util/util.h"

//https://github.com/OneLoneCoder/videos/blob/master/OneLoneCoder_PathFinding_AStar.cpp
List<Point> AStar::FindPath(const Point &from, const Point &to) {

    List<Point> path;

    if(from == to) {
        path.push_back(to);
        return path;
    }

    for(auto i = 0; i < kNumTiles; i++) {
        for(auto j = 0; j < kNumTiles; j++) {
            nodes_[i][j] = Node({j, i});
        }
    }

    auto *end = &nodes_[to.y][to.x];

    //Initialize current with start info
    auto *current = &nodes_[from.y][from.x];
    current->local_goal = 0;
    current->global_goal = current->Heuristic(*end);

    //Because we can't use lambdas rip
    class NodeComparator : public PriorityQueue<Node*>::Comparator {
    public:
        bool HigherPriority(Node* const &a, Node* const &b) override {
            return *a < *b;
        }
    };

    NodeComparator comparator;

    PriorityQueue<Node*> to_visit(&comparator);

    to_visit.push(current);
    
    while(!to_visit.empty() && current != end) {

        while(!to_visit.empty() && to_visit.front()->visited)
            to_visit.pop();

        if(to_visit.empty())
            break;

        current = to_visit.front();
        current->visited = true;

        constexpr size_t kNumNeighbors = 8;

        Node* neighbors[kNumNeighbors];

        const auto x = current->point.x;
        const auto y = current->point.y;

        neighbors[0] = y > 0                                    ? &nodes_[y - 1][x] : nullptr;
        neighbors[1] = x > 0                                    ? &nodes_[y][x - 1] : nullptr;
        neighbors[2] = y < kNumTiles - 1                        ? &nodes_[y + 1][x] : nullptr;
        neighbors[3] = x < kNumTiles - 1                        ? &nodes_[y][x + 1] : nullptr;
        neighbors[4] = y > 0 && x > 0                           ? &nodes_[y - 1][x - 1] : nullptr;
        neighbors[5] = y > 0 && x < kNumTiles - 1               ? &nodes_[y - 1][x + 1] : nullptr;
        neighbors[6] = y < kNumTiles - 1 && x > 0               ? &nodes_[y + 1][x - 1] : nullptr;
        neighbors[7] = y < kNumTiles - 1 && x < kNumTiles - 1   ? &nodes_[y + 1][x + 1] : nullptr;

        for(auto neighbor : neighbors) {
            //Neighbor does not exist in this direction
            if(neighbor == nullptr)
                continue;

            if(!neighbor->visited && !map_.tiles[neighbor->point.y][neighbor->point.x].IsWall()) {
                to_visit.push(neighbor);
            }

            float possibly_lower_goal = current->local_goal + current->Heuristic(*neighbor);

            if(possibly_lower_goal < neighbor->local_goal) {
                neighbor->parent = current;
                neighbor->local_goal = possibly_lower_goal;
                neighbor->global_goal = neighbor->local_goal + neighbor->Heuristic(*end);
            }

        }

    }


    current = end;
    while(current != nullptr) {
        path.push_front(current->point);
        current = current->parent;
    }

    path.push_front(from);

    return OptimizeAndConvert(path);
}

List<Point> AStar::OptimizeAndConvert(List<Point> &path) {

    List<Point> optimized;

    //Add end point
    optimized.push_front(TileToPixels(path.pop_back()));

    bool prev_was_adj_pass = false;
    bool prev_diagonal = false;

    while(!path.empty()) {
        auto current = path.pop_back();
        auto before = path.back();

        const Point wall = PotentialWallPass(before, current);
        const bool did_pass_wall = wall.x >= 0;

        const bool diagonal = current.x != before.x && current.y != before.y;

        //Avoid collision with wall
        if(did_pass_wall) {
            auto new_current = TileToPixels(current);

            new_current.x -= 4 * (wall.x - before.x);
            new_current.y -= 4 * (wall.y - before.y);

            optimized.push_front(new_current);
        }
        //If we are moving in the same direction, don't add the point
        else if(prev_was_adj_pass || (diagonal && !prev_diagonal)) {
            optimized.push_front(TileToPixels(before));
        }

        prev_was_adj_pass = did_pass_wall;
        prev_diagonal = diagonal;
    }

    return optimized;
}

Point AStar::PotentialWallPass(const Point &from, const Point &to) {

    //The walls we may be passing. From the spimbot
    //spec this will never be both.
    const Point blocks[2] = {
            {to.x, from.y},
            {from.x, to.y}
    };

    for(const auto &block : blocks) {
        if(block.x >= 0 && block.y >= 0 && block.x < kNumTiles && block.y < kNumTiles
            && map_.tiles[block.y][block.x].IsWall())
            return block;
    }

    return {-1, -1};
}
